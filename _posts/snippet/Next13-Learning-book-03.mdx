---
title: "[Next.js V13] 정리 노트 - 3"
description: "서버 컴포넌트에 데이터 Fetching 하기 With PostgreSQL and Prisma"
language: "PostgreSQL"
category: "NextJS"
update: "2023-03-08"
serisenumber: 3
---
## Intro
---
- 본 내용은 강의 제공 사이트 유데미 Laith Harb 강사님의 "The Next.js 13 Bootcamp - The Complete Developer Guide" 강의를 듣고 정리하였습니다.
- [https://www.udemy.com/course/the-nextjs-13-bootcamp-the-complete-developer-guide/](https://www.udemy.com/course/the-nextjs-13-bootcamp-the-complete-developer-guide/)

### 이 시간에
---
이전까지 과정을 보면 컴포넌트내 들어가는 음식 이름, 소개 등 모두 텍스트만 입력해 하드코딩되어 있었습니다. 이제 실제 데이터베이스에서 데이터를 가져와 서버 컴포넌트에 붙여보도록 합니다. 데이터베이스는 Postgres를 사용할 것이며 이 데이터 베이스에 대해 정리해보도록 하겠습니다.

### PostgreSQL
---
postgreSQL은 관계형 데이터베이스입니다. 기존 관계형 데이터베이스와 다르게 특출난 점은 데이터 행마다 git과 같이 버전관리가 진행되는것입니다. 이와 관련된 내용은 추후 알아보도록 하겠습니다.

### Superbase를 이용해 데이터베이스 구성
---
백엔드 구현에는 꽤 시간이 걸리므로 파이어베이스와 같은 클라우드 환경의 백엔드를 구축해봅시다. 그중 `PostgreSQL`을 지원하는 [Superbase](https://supabase.com/)를 이용하겠습니다. 또한 데이터베이스 매핑을 위한 도구로 `Prisma`를 이용하겠습니다.
```bash
npm i prisma@4.8.1
```
설치 완료 후 이 프로젝트에서`prisma`사용을 위해 초기화합니다.
```bash
npx prisma init
```

초기화 이후 프로젝트 폴더내 `prisma`폴더, `.evn`파일이 생성되며 데이터 베이스 연결 및 model생성이 가능합니다.
```text
내 프로젝트 폴더 이름
├── pages
├── public
│   └── config.json
├── prisma
│   └── schema.prisma
├── .env
...
```
`env`파일에는 데이터베이스에 연결할 URL을 입력해줍니다. 현재 단계에서는 `Superbase`에서 생성한 데이터베이스의 커넥션 URL을 입력해주겠습니다.
```json
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="커넥션 주소"
```

### 테이블 구성하기
---
다음과 같은 구조로 테이블을 구성해보겠습니다.

`1. Restaurant`

![스크린샷 2023-03-08 오후 2 17 57](https://user-images.githubusercontent.com/51357635/223626300-d0902222-50be-4367-ae6d-0c1a1d10383f.png)

`2.Items`

![스크린샷 2023-03-08 오후 2 18 07](https://user-images.githubusercontent.com/51357635/223626310-d9acdf98-bba7-4801-a5e2-46631d7612fe.png)

`3.Location`

![스크린샷 2023-03-08 오후 2 18 19](https://user-images.githubusercontent.com/51357635/223626321-c062e36e-91bc-45db-8516-c465ce864304.png)

`4.Cuisine`

![스크린샷 2023-03-08 오후 2 18 29](https://user-images.githubusercontent.com/51357635/223626330-6202f500-86aa-4c71-b476-e6a75feeb80d.png)

위에 정의한 테이블을 `prisma`를 이용해 스키마를 정의하면 다음과 같은 코드로 만들 수 있습니다.
```json
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// @id -> 기본키로 지정
// @updatedAt -> 업데이트 때마다 변경할 수 있도록 제약
// @default -> 기본값 지정
// @unique -> 유니크값 지정
// Item[] 여러 Item을 가짐.
model Restaurant {
  id            Int     @id     @default(autoincrement())
  name          String
  main_image    String
  images        String[]
  description   String
  open_time     String
  close_time    String
  slug          String    @unique
  price         PRICE
  items         Item[]
  location_id   Int
  location      Location    @relation(fields: [location_id], references: [id])
  cuisine_id    Int
  cuisine       Cuisine     @relation(fields: [cuisine_id], references: [id])
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

// Restaurant (1) : Item (N)
// restaurant    Restaurant  @relation(fields: [restaurant_id], references: [[id]])
// Restaurant 테이블의 id값을 Item 필드의 restaurant_id가 참조
model Item {
  id            Int       @id     @default(autoincrement())
  name          String
  price         String
  description   String
  restaurant_id Int
  restaurant    Restaurant  @relation(fields: [restaurant_id], references: [id])
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

// Restaurant (N) : Location (1)
model Location {
  id            Int       @id     @default(autoincrement())
  name          String
  restaurants   Restaurant[]
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

// Restaurant (N) : Cuisine (1)
model Cuisine {
  id            Int       @id     @default(autoincrement())
  name          String
  restaurants   Restaurant[]
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

// enum 을 추가해 특정 문자열만 입력되는 타입으로 사용할 수 있다.
enum PRICE {
  CHEAP
  REGULAR
  EXPENSIVE
}
```

이후 마이그레이션을 위해 다음과 같이 명령을 실행합니다.
```bash
npx prisma db push
```

이후 실제 데이터베이스로 이동하면 테이블이 생성되어있을겁니다.

### 더미 데이터 생성하기
---
테스트를 위해 생성된 테이블에 더미 데이터를 생성할 수 있습니다. `pages` 폴더내 seed 파일을 만들고 `/api/seed`를 요청하면 더미 데이터를 생성할 수 있습니다.
[더미 데이터 생성하기 Prisma](https://www.prisma.io/docs/guides/database/seed-database) 참고

### 서버 컴포넌트에 데이터 패칭
---
메인페이지에서 데이터가 정상적으로 조회되는지 확인해봅시다.

우선 restaurant에서 조회할 값은 `id, name, main_image, cuisine, location, price`입니다.
먼저 restaurant정보는 하위 `RestaurantCard`컴포넌트에 값을 전달해야하므로 인터페이스를 설정한 후 해당 인터페이스의 배열을 반환타입으로 설정하여 `prisma`를 이용해 데이터를 불러옵니다.
```tsx
// /app/page.tsx
import Header from './components/Header'
import RestaurantCard from './components/RestaurantCard'
import { PrismaClient, Cuisine, Location, PRICE } from '@prisma/client'

export interface RestaurantCardType {
  id: number;
  name: string;
  main_image: string;
  cuisine: Cuisine,
  location: Location,
  price : PRICE
}

const fetchRestaurants = async () : Promise<RestaurantCardType[]> => {
  const restaurants = await prisma.restaurant.findMany({
    select: {
      id: true,
      name: true,
      main_image: true,
      cuisine: true,
      location: true,
      price: true
    }
  });

  return restaurants;
}

export default async function Home() {

  const restaurants = await fetchRestaurants();

  // 서버 컴포넌트이므로 브라우저에서 콘솔창을 열어도 보이지 읺음. 서버측에서만 보임.
  console.log({restaurants});
  return (
    <main>
      <Header/>
      <div className="py-3 px-36 mt-10 flex flex-wrap justify-center">
        {restaurants.map(restaurant => (
          <RestaurantCard restaurant={restaurant}/>
        ))}
        {/* <RestaurantCard/> */}
      </div>
    </main>
  )
}
```
또한 하위 컴포넌트 `RestaurantCard`에서 `RestaurantCardType`타입을 전달받을 속성을 인터페이스로 정의한 후 해당 인터페이스를 타입으로 가질 객체를 받는다고 타입을 정의합니다.
```tsx
// /app/components/RestaurantCard.tsx
"use client"

import { useRouter } from "next/navigation";
import { useState } from "react";

export default function SearchBar() {
  const router = useRouter();
  const [location, setLocation] = useState("");

  return (
    <div className="text-left text-lg py-3 m-auto flex justify-center">
      <input
        className="rounded  mr-3 p-2 w-[450px]"
        type="text"
        placeholder="State, city or town"
        value={location}
        onChange={(e) => setLocation(e.target.value)}
      />
      <button className="rounded bg-red-600 px-9 py-2 text-white" onClick={() => {
        if(location === "banana") return;
        router.push("/search");
      }}>
        Let's go
      </button>
    </div>
  )
}
```
