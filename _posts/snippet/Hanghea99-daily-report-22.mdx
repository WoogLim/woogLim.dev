---
title: "[항해] 항해 심화 주차 - 6"
description: "Layered Architecture Pattern"
language: "daliyreport"
category: "Hanghae99"
update: "2023-03-11"
serisenumber: 22
---

## Layered Architecture Pattern

### 도메인
- 개발자 대부분은 비즈니스 프로세스를 개선하거나 자동화하기 위해 일한다. 도메인은 이런 프로세스가 지원하는 활동을 의미한다.
- 가구 판매 회사의 도메인은 구매 및 조달, 제품 설계, 물류 및 배달 등 다른 분야를 뜻할 수 있습니다.

**도메인 (Domain)의 예시**

- 개발자 입장에서 온라인 서점을 구현해야 할 **소프트웨어의 대상**이 됩니다.
    - **온라인 서점** = 소프트웨어로 해결하고자 하는 **문제의 영역** = **도메인 (Domain)**
- 한 **도메인**은 다시 **하위 도메인**으로 나눌 수 있습니다.
    - **도메인 구성** : 주문, 회원, 혜택, 결제, 배송, 정산, 카탈로그, 리뷰
    - **하위 도메인**은 **다른** 하위 도메인과 **연동**하여 완전한 기능을 제공합니다.
        - ex) 고객 → 물건 주문 → 결제 → 배송 → 혜택 제공
- **하위 도메인**을 어떻게 구성할 지 여부는 상황에 따라 달라집니다.
    - **B2B**(Business-to-Business), **B2C**(Business to Consumer)

### 도메인 모델
- **도메인 모델**이란 유용한 특성을 포함하는 **프로세스**나 현상의 **지도**(Map)를 뜻합니다. **도메인 모델**은 비즈니스를 수행할 사람이 자신의 비즈니스에 대해 **마음속에 가지고 있는 지도**와 같습니다.

- **도메인 모델**이란 특정 도메인을 **개념적으로 정리**한 모델입니다.
- **도메인 모델**은 사용할 개체를 기억하기 쉬운 이름(**식별자**)을 부여해 **대상을 쉽게 공유**할 수 있게 한다.
- 만약 누군가가 저희에게 공을 던진다면 우리는 **무의식적**으로 이 공의 움직임을 **예측**해 회피할 것입니다.
    - 우리들의 머릿속에 이미 공간상 물체가 **움직이는 방식에 대한 모델**이 있어서 움직임을 무의식적으로 **예측**할 수 있습니다.

**도메인 모델링 (Domain Modeling)의 종류**

1. **엔티티 (Entity)**
2. **값 객체 (Value object)**
3. **도메인 서비스 (Domain service)**

#### 엔티티
- 엔티티(Entity)는 실제 DB 테이블과 연관되어 있는 핵심 클래스이고, 엔티티를 기준으로 테이블이 생성되고 DB 스키마가 변경됩니다.  
ex) Sequelize Models

- **엔티티**를 **요청(Request)**이나 **응답값(Response)**으로 전달하는 클래스로 사용하면 안됩니다.
- **엔티티** **내부의 속성**이 **변경**되더라도 여전히 **동일한 엔티티**로 남아있습니다.
- **엔티티**는 시간에 따라 **변하는 속성**이 **포함**될 수 있습니다.
- 어떤 요소가 **엔티티**를 **유일하게 식별**하는지 **정의**하는 것 또한 중요합니다.
    - 보통 이름이나 참조 번호 등을 사용합니다.
    - ex) `User` 클래스의 `userId`

### 아키텍처 패턴
- 아키텍처 패턴은 소프트웨어의 구조를 구성하기위한 가장 기본적인 토대를 제시합니다.
- **아키텍처 패턴**은 각각의 **시스템**들과 그 **역할**이 정의되어 있고, 여러 시스템 사이의 **관계**와 **규칙** 등이 포함되어 있습니다.
- 검증된 구조로 개발을 진행하기 때문에 **안정적인 개발**이 가능합니다.
- 아키텍처 패턴을 도입할 경우 도메인이 **복잡**할수록 **모델**이나 **코드**를 더 쉽게 변경할 수 있다는 측면에서 **큰 이익**을 얻을 수 있습니다.

**대표적인 아키텍처 패턴**

- **저장소 패턴 (Repository pattern)**
    - **영속적인 저장소**에 대한 **추상화**
- **서비스 계층 패턴 (Service layer pattern)**
    - 유스 케이스(Usecase)의 **시작**과 **끝**을 명확하게 정의하기 위한 패턴
- **작업 단위 패턴 (Unit of work pattern)**
    - 원자적 연산을 제공합니다.
- **애그리게이트 패턴 (Aggregate pattern)**
    - 데이터 정합성을 강화하기 위한 패턴

- 아키텍처 패턴을 도입하기 전에 고민해야 할 것
    1. 아키텍처 패턴이 주는 **이익**과 **비용**에 대해 **확실한 이유**가 있어야합니다.
    2. 해당하는 아키텍처 패턴을 채택했을 때 어떤 **장단점**이 존재하는지 **명확하게 인지**해야 합니다.
    3. **여러 계층**을 추가하기 위해 들이는 **노력**과 **시간**을 투자할 만한 가치가 있을 정도로 **어플리케이션**과 **도메인**이 **복잡한** 경우에만 아키텍처 패턴을 **도입**해야 합니다.

### 계층형 아키텍처 패턴
- 계층형 아키텍처 패턴(Layered Architecture Pattern)은 계층을 분리해서 관리하는 아키텍처 패턴이고, 현재 가장 흔하게 사용되고 있는 아키텍처 패턴 중 하나입니다.
**단순**하고 **대중적**이면서 **비용도 적게** 들어 모든 어플리케이션의 사실상 **표준 아키텍처**입니다.

어떤 아키텍처 패턴을 도입할지 확신이 없을 때에는 **계층형 아키텍처 패턴**은 좋은 선택지가 될 수 있습니다.

계층형 아키텍처 패턴은 어떤 경우든 **계층을 분리해서 유지**하고, **각 계층이 자신의 바로 아래 계층에만 의존**하게 만드는 것이 **목표**입니다.

계층화의 핵심은 각 계층은 응집도(Cohesion)가 높으면서, 다른 계층과는 낮은 결합도(Coupling)를 가지고 있어야합니다.

여기서 상위 계층은 하위 계층을 사용할 수 있지만, 하위 계층은 자신의 상위 계층에 누가 있는지 알 수 없고, 사용할 수 조차 없도록 구성해야합니다.

일반적으로 계층형 아키텍처 패턴의 경우 규**모가 작은 어플리케이션의 경우 3개**, **크고 복잡한 경우는 그 이상의 계층으**로 구성됩니다.

저희가 알아볼 아키텍처 패턴은 **3계층 아키텍처(3-Layered Architecture)**입니다.

**3계층 아키텍처**에서 구성되는 각각의 **계층(Layer)**는 아래와 같습니다.

- **프레젠테이션 계층 (Presentation Layer)**
- **비즈니스 로직 계층 (Business Logic Layer)**
- **데이터 엑세스 계층 (Data Access Layer) | 영속 계층(Persistence Layer)**

[그림 - 아키텍처 패턴]

- 계층형 아키텍처 패턴의 장점
  저희는 이렇게 계층별로 아키텍처를 분리했을때 아래의 **장점**을 얻을 수 있습니다.
  - **관심사를 분리**하여 현재 구현하려하는 **코드**를 **명확하게 인지**할 수 있습니다.
  - 각 계층별로 의존성이 낮아 **모듈**을 **교체**하더라도 코드 수정이 **용이**합니다.
  - 각 계층별로 **단위 테스트**를 작성할 수 있어 **테스트 코드**를 조금 더 **용이**하게 **구성**할 수 있습니다.

- 3계층 아키텍처 (**3-Layered Architecture**)
    
    **3-Layered Architecture**는 아래의 3가지의 처리과정을 이용해서 구현합니다.
    
    1. **Controller** : 어플리케이션의 가장 바깥 부분, 요청/응답을 처리함.
        - 클라이언트의 **요청**을 처리 한 후 서버에서 처리된 **결과**를 **반환**해주는 **역할**을 합니다.
    2. **Service** : 어플리케이션의 중간 부분, 실제 중요한 작동이 많이 일어나는 부분
        - 아키텍처의 가장 핵심적인 **비즈니스 로직**이 수행되는 부분입니다.
    3. **Repository** : 어플리케이션의 가장 안쪽 부분, DB와 맞닿아 있음.
        - 실제 **데이터베이스**의 데이터를 사용하는 계층입니다.

**3-Layered Architecture**에서는 아래의 **플로우**를 기반으로 로직이 수행됩니다.

1. **클라이언트(Client)**가 **요청(Request)**을 보냅니다.
2. **요청(Request)**을 URL에 알맞은 **컨트롤러**(**Controller)**가 수신 받습니다.
3. **컨트롤러**(**Controller)**는 넘어온 **요청**을 **처리**하기 위해 **서비스(Service)**를 호출합니다.
4. **서비스(Service)**는 필요한 **데이터**를 가져오기위해 저**장소(Repository)**에게 **데이터**를 요청합니다.
5. **서비스(Service)**는 **저장소(Repository)**에서 가져온 데이터를 **가공**하여 **컨트롤러**(**Controller)**에게 **데이터**를 넘깁니다.
6. **컨트롤러**(**Controller)**는 **서비스(Service)**의 **결과물(Response)**을 **클라이언트(Client)**에게 전달해줍니다.

- 👉 서버 개발자들은 서버에서의 처리과정이 대부분 비슷하다는 걸 깨닫고, 처리 과정을 크게 3개로 분리하였고 **Controller, Service, Repository** 입니다. 각 역할 별로 하는 일을 정리해 보겠습니다.

#### Controller

[그림 - 컨트롤러]

- 클라이언트의 요청을 받음
- 요청에 대한 처리는 서비스에게 전담
- 클라이언트에게 응답

#### Service

[그림 - 서비스]

- 사용자의 요구사항을 처리 ('비즈니스 로직') 하는 **실세!**
    - 현업에서는 서비스 코드가 계속 비대해짐
- DB 정보가 필요할 때는 Repository 에게 요청

#### Repository

[그림 - 리포지토리]

- DB 관리 (연결, 해제, 자원 관리)
- DB CRUD 작업 처리

최종적으로 다음과 같은 그림이 됩니다.

[그림 - 전체 그림]