---
title:  "[Docker Mastery] - 14"
description:  "쿠버네티스 Volume"
language:  "devops"
category:  "Docker"
update:  "2024-04-12"
hide:  false
serisenumber:  14
---

## 시작

- [Maximilian Schwarzmüller 님의 Docker & Kubernetes : 실전 가이드 강의를 듣고 작성한 글입니다.](https://www.udemy.com/course/docker-kubernetes-2022/?couponCode=KEEPLEARNING)

### 볼륨

minikube는 호스트내 가상머신입니다. 컨테이너를 배포할때 클러스터 혹은 호스트에서 도커로 작업할 때, 컨테이너가 종료되거나 컨텍스트에서 호스팅하는 Pod가 제거되면 데이터가 유실됐죠. 이제 데이터를 유실하지 않고 관리하는 방법에 대해 알아보겠습니다.

볼륨의 종류로는 일반 볼륨, 영구 볼륨, 영구 볼륨 클레임이 존재합니다. 순차적으로 알아봅시다.

#### State 이해하기

사용자 생성 데이터, 사용자 계정, 앱에 관한 데이터 등 일반적으로 DB에 저장하지만 예로 파일로도 저장할 수 있죠. 임시 DB테이블인 메모리에 저장할 수도 있구요. 컨테이너가 중지되더라도 이러한 데이터들은 유실되면 안되겠죠.

이제 파드내 컨테이너에 볼륨을 구성하는 방법을 알아봅시다.

쿠버네티스는 마운트 볼륨을 설정하는 것을 지원합니다. 로컬 볼륨(워커노드) 말고도 또한 다른 클라우드 및 호스팅 프로바이더에서도 사용할 수 있어 다양한 유형의 볼륨을 이용할 수 있습니다.

볼륨은 파드마다 존재합니다. 생명주기도 파드를 따라갑니다. 컨테이너를 중지하면 볼륨은 살아있지만 Pod가 파괴되면 볼륨 또한 파괴됩니다. Pod또한 일종의 컴퓨터라고 보면 되겠군요. Pod를 제거한 후에도 볼륨을 유지하는 방법이 존재합니다. 이에 대해서는 차후 알아보겠습니다.

쿠버네티스 볼륨은 도커보다 조금 더 강력합니다. 다양한 드라이버와 유형을 지원하며 데이터가 저장되는 위치를 완벽히 제어할 수 있죠.

볼륨은 반드시 영구적인 것은 아닙니다. 쿠버네티스에서 컨테이너는 Pod의 재시작에도 살아있지만 볼륨은 제거됩니다. 반면 도커는 제거하지 않는 한 볼륨이 살아있죠.

### 시작하기

우선 다음과 같은 Node 서버를 실행합니다. API는 다음과 같습니다.
```js

const filePath = path.join(__dirname, 'story', 'text.txt');

app.get('/story', (req, res) => {
  fs.readFile(filePath, (err, data) => {
    if (err) {
      return res.status(500).json({ message: 'Failed to open file.' });
    }
    res.status(200).json({ story: data.toString() });
  });
});

app.post('/story', (req, res) => {
  const newText = req.body.text;
  if (newText.trim().length === 0) {
    return res.status(422).json({ message: 'Text must not be empty!' });
  }
  fs.appendFile(filePath, newText + '\n', (err) => {
    if (err) {
      return res.status(500).json({ message: 'Storing the text failed.' });
    }
    res.status(201).json({ message: 'Text was stored!' });
  });
});
```

이미지 빌드를 위해 Dockerfile을 작성합니다.

```yaml
FROM node:14-alpine

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 3000

CMD [ "node", "app.js" ]
```

deployments yaml 입니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: story-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: story
  template:
    # kind: Pod
    metadata:
      labels:
        app: story
    spec:
      containers:
      - name: story
        image: 생성한 이미지
```

이어서 service yaml 입니다.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: story-service
spec:
  selector:
    # matchLabels: 생략
    app: story
  type: LoadBalancer
  ports:
  - protocol: "TCP"
    # 외부 노출 포트
    port: 80
    targetPort: 3000
```

서비스 및 배포를 실행합니다.

```bash
kubectl apply -f=service.yaml -f=deployment.yaml

> kubectl get deployments
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
story-deployment   1/1     1            1           3d2h
> kubectl get service
NAME            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
kubernetes      ClusterIP      10.96.0.1       <none>        443/TCP        9d
story-service   LoadBalancer   10.107.85.248   <pending>     80:31774/TCP   3d2h
> minikube service story-service
|-----------|---------------|-------------|---------------------------|
| NAMESPACE |     NAME      | TARGET PORT |            URL            |
|-----------|---------------|-------------|---------------------------|
| default   | story-service |          80 | http://192.168.49.2:31774 |
|-----------|---------------|-------------|---------------------------|
🏃  story-service 서비스의 터널을 시작하는 중
|-----------|---------------|-------------|------------------------|
| NAMESPACE |     NAME      | TARGET PORT |          URL           |
|-----------|---------------|-------------|------------------------|
| default   | story-service |             | http://127.0.0.1:50204 |
|-----------|---------------|-------------|------------------------|
🎉  Opening service default/story-service in default browser...
❗  darwin 에서 Docker 드라이버를 사용하고 있기 때문에, 터미널을 열어야 실행할 수 있습니다
```

해당 서비스에서는 GET 요청으로 텍스트의 저장 텍스트를 불러오고 POST요청으로는 텍스트를 저장합니다. 이 상황에서 파드가 재시작된다면 데이터는 사라질겁니다.

데이터를 제거하지 않도록 [볼륨](https://kubernetes.io/docs/concepts/storage/volumes/) 설정을 시작해봅시다. 

쿠버네티스는 다양한 볼륨 타입과 드라이버를 제공합니다. 지금은 minikube 를 이용해 로컬에서 가상머신으로 노드를 구성하고 있습니다.

특정 클라우드 프로바이더 또는 데이터 센터에 서비스를 배포하려면 공식 DOCS를 참고하면 됩니다. 다양한 볼륨 및 타입별 YAML 작성법이 나와있으니 참고하시길 바랍니다.

우선 CSI 유형에 중점을 두고 진행합니다. `emptyDir` > `hostPath` 순으로 진행하겠습니다.

### emptyDir 유형으로 볼륨 구성하기

볼륨의 수명은 파드와 직결됩니다. 파드별로 다르구요. 때문에 Pod를 정의하는 위치에 볼륨을 정의해야 합니다.

이전 이미지를 빌드하기전 코드를 수정합니다.

```js
app.get('/error', () => {
  process.exit(1)
})
```

error API를 호출하면 서버가 종료되도록 해봅시다. 이상 징후가 발견되면 컨트롤 플레인에서 파드를 재실행할겁니다.

deployment yaml에서 이미지를 변경한 뒤 설정 파일을 적용합니다.

```bash
kubectl apply -f=deployment.yaml

# 파드가 정상 실행되면 이전 파드는 제거됨.
kubectl get pods
NAME                                READY   STATUS        RESTARTS      AGE
story-deployment-7db5f4c576-f9z8c   1/1     Running       0             32s
story-deployment-cbf5f7f47-fg72b    1/1     Terminating   1 (40m ago)   3d3h

minikube service story-service
```

이제 아래와 같이 파드가 실행됐을때, 요청을 보내봅시다.

```bash
> kubectl get pods
NAME                                READY   STATUS    RESTARTS     AGE
story-deployment-7db5f4c576-f9z8c   1/1     Running   1 (7s ago)   2m18s
```

파드가 정상 실행중입니다. Postman을 이용해 Post 요청을 보냅니다.

![volume-test-post](/snippets/kube/chap2/postman-post.png)

텍스트를 조회한 결과입니다.

![volume-test-get](/snippets/kube/chap2/postman-get.png)

서비스가 종료되도록 에러를 발생시킵니다.

![volume-error-get](/snippets/kube/chap2/postman-error-get.png)

컨테이너에 이상이 감지되어 파드를 재시작합니다.

```bash
> kubectl get pods
NAME                                READY   STATUS   RESTARTS       AGE
story-deployment-7db5f4c576-f9z8c   0/1     Error    1 (108s ago)   3m59s
> kubectl get pods
NAME                                READY   STATUS             RESTARTS      AGE
story-deployment-7db5f4c576-f9z8c   0/1     CrashLoopBackOff   1 (14s ago)   4m6s
> kubectl get pods
NAME                                READY   STATUS    RESTARTS      AGE
story-deployment-7db5f4c576-f9z8c   1/1     Running   2 (16s ago)   4m8s
```

다시 GET 요청을 보내지만 이전 데이터는 제거됩니다.

![retry-volume-test-get](/snippets/kube/chap2/postman-retry-get.png)

이제 서비스가 종료되어도 데이터가 보존되도록 설정을 변경해보겠습니다.

