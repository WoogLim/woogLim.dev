---
title: "타입스크립트 기본 타입"
description: "타입스크립트 기본 & 기본 타입"
language: "Typescript"
category: "Typescript Tutorial"
update: "2022-06-24 20:08:12"
serisenumber: "2"
---

## Intro

---

- [Maximilian Schwarzmüller 강사님의 Typescript 강의를 듣고 TIL 방식으로 정리한 글입니다.](https://www.udemy.com/course/understanding-typescript/)

## 타입스크립트 기본 타입

---

타입스크립트의 주요 원시 타입은 모두 소문자이다. **String (X)** **string (O)**

### number 타입

---

정수, 실수형에 따른 타입은 없으며 숫자는 모두 **number** 타입이다.

```ts
let num: number = 0;

num = 1;
num = 5.2;
num = 10;
```

### string 타입

---

일반적인 문자 및 문자열 타입이다.

```ts
let str: string = "";

str = "Hi";
str = "Hi";
str = `Hi`;
```

### Boolean 타입

---

일반적인 Boolean 타입이다.

```ts
let check: booelan = false;

check = true;
check = false;
```

## 타입 할당과 추론

---

### 타입 할당

---

아래 코드의 **`add`**함수의 경우 매개변수마다 타입이 명시적으로 지정되어있다. 이를 타입 할당이라고 한다.

```ts
// app.ts
function add(n1: number, n2: number, showResult: boolean, phrase: string) {
  const result = n1 + n2;
  if (!showResult) {
    console.log(phrase + result);
  } else {
    return result;
  }
}
```

### 타입 추론

---

명시적으로 타입이 배정되지 않은 경우 초기화된 값으로 타입을 추론해 할당한다.
`number1, number2`의 경우 **`number`**타입 값으로 초기화 했디 때문에 `number`타입이다.
let 변수 방식으로 초기화 한 변수의 타입을 보면 number인 것을 볼 수 있다.<br/>

만일 매개변수 타입이 고정되지 않는 경우 타입을 지정하지 않는 방식으로 사용한다.
이때 타입은 **`any`**타입이다.
추론된 타입이라도 해당 타입을 어기면 에러가 발생한다.<br/>

```ts
// app.ts
let number1 = 5; // let nubmer1 : number = 5;
const number2 = 2.8;
const printResult = true;
let resultPhrase = "Result is: "; // string

resultPhrase = 0; // Type '0' is not assinable to type 'string'.
```

## 객체(object) 형태에서의 타입

---

객체 형태의 키 또한 타입 할당/추론을 통해 타입이 매겨진다.

### 객체 형태의 타입 추론

---

객체 형태의 타입 추론의 경우 타입을 명시하지 않으면 초기화된 값으로 타입이 매겨진다.

```ts
// basic.ts

const person = {
    name: 'Lim', // string
    age: 27 // number
};

console.log(person);
>> {name: "Lim", age: 27}

console.log(person.name);
>> Lim
```

### 객체 형태의 타입 할당

---

객체에 타입을 지정하는 경우 키와 값의 타입을 할당해야한다.
`object`로 타입을 정의한 경우 키와 값의 타입 지정이 안되어 있기 때문에 값을 조회하는 경우 에러가 발생한다.<br/>
때문에 키와 타입의 값이 만들어진 **`{}`** 타입을 할당한다.

```ts
const persontest: object = {
    name: 'Lim',
    age: 27
}

console.log(persontest.name)
>> Property 'name' does not exist on type 'object';

const person: {
    name: string;
    age: number;
} = {
    name: 'Lim',
    age: 30
};

console.log(person.name)
>> Lim
```

### 객체 안에 객체 타입을 지정하는 경우

---

객체 안에 객체가 있는 경우의 타입도 할당/추론을 통해 타입이 매겨진다.

```ts
const person: {
  name: string;
  age: number;
  address: {
    zip: number;
    datail: string;
  };
} = {
  name: "Lim",
  age: 27,
  address: {
    zip: 41242,
    detail: "서울특별시 중랑구",
  },
};
```

## 배열(Array) 타입

---

배열타입의 경우 자료형[] 형태로 타입을 할당할 수 있다.

```ts
// array.ts
const person = {
  name: "Lim", // string
  age: 27, // number
  hobbies: ["Health", "Game"], //string[]
};
```

여러 타입의 값이 들어가는 경우 `any`를 이용할 수 있다.

```ts
// array.ts
let favoriteActivities: any[];
favoriteActivities = ["Health", 1];
```

타입 추론을 통해 할당된 타입을 통해 for 문을 이용하는 경우 타입을 지정하지 않아도 된다.

```ts
for (const hobby of person.hobbies) {
  // const hobby: sring
  console.log(hobby); // 이미 person.hobbies가 string인 이유로
  // 추론을 통해 string인 것을 알 수 있음.
}
```

## 튜플(Tuple) 타입

---

타입스크립트에서 **새로 추가된 타입**이다. (자바스크립트에는 없다.) <br/>
배열과 비슷하지만 **길이와 타입이 고정**된다.  
만일 `[2,'author']`과 같이 값이 할당된 경우 해당 튜플의 타입은 `(string | number)[]` 이 된다.
이는 **첫 요소는 문자열 두번째 요소는 문자열**를 저장할 수 있는 배열을 값으로 가질 수 있다.
공용체 타입[unit] 이라고도 한다.

```ts
// tuple.ts
const person = {
  name: "Lim", // string
  age: 27, // number
  hobbies: ["Health", "Game"], //string[]
  role: [2, "author"], // role : (string | number)[]
};
```

타입 할당은 아래와 같은 방법을 사용한다.<br/>
값을 할당하는 도중 `push`의 경우는 **에러를 발생시키지 않는다.** 예외적으로 튜플에서 허용되기 때문이다.
하지만 에러 표시를 하지 않을뿐 길이를 넘긴다면 잘못된 값을 할당하진 않는다.

```ts
// tuple.ts
const person: {
  name: string;
  age: number;
  hobbies: string[];
  role: [number, string]; // 튜플 타입
} = {
  name: "Lim", // string
  age: 27, // number
  hobbies: ["Health", "Game"], //string[]
  role: [2, "author"], // role : (string | number)[]
};

person.role.push("admin"); // 푸시는 예외적으로 튜플에서 허용되어 타입스크립트는 에러를 발생시키지 않는다.
person.rile[1] = 10; // 두번째 요소 타입은 string으로. number를 두번째 요소로 지정하면 에러가 발생한다.

person.role = [0, "admin"];
```

배열의 타입을 이미 알고 있는 상황에서는 작업 중인 데이터 타입과 예상되는 데이터 타입은 명확히 파악할 수 있다.

## 열거형(Enum) 타입

식별자 및 전역 상수등을 정의하는 열거형타입또한 **타입스크립트에서 추가**되었다.
쉽게 사용권한을 체크하는 경우 아래와 같은 코드를 사용할 수 있을 것이다.

```ts
// enum.ts
const ADMIN = 0;
const READ_ONLY = 1;
const AUTHOR = 2;

const person = {
    name: 'Lim',
    age: 27,
    hobbies: ['Health', 'Game'],
    role: ADMIN
}

if(person.role === ADMIN) {
    console.log("is admin")
    >> is admin
}
```

enum 키워드로 보다 효울적으로 위와같은 권한의 상수를 정의하고 관리할 수 있다.<br/>
enum 은 각 라벨을 숫자로 할당해준다.

```ts
// enum.ts
enum Role {
  ADMIN,
  READ_ONLY,
  AUTHOR,
} // ADMIN = 0, READ_ONLY = 1, AUTHOR = 2

const person = {
  name: "Lim",
  age: 27,
  hobbies: ["Health", "Game"],
  role: Role.ADMIN,
};

if (person.role === Role.AUTHOR) {
  console.log("is author");
}
```

컴파일 이후에는 아래와 같은 자바스크립트로 컴파일되어 브라우저에 적용된다.

```js
var Role;
(function (Role) {
  Role[(Role["ADMIN"] = 0)] = "ADMIN";
  Role[(Role["READ_ONLY"] = 1)] = "READ_ONLY";
  Role[(Role["AUTHOR"] = 2)] = "AUTHOR";
})(Role || (Role = {}));

var person = {
  name: "Lim",
  age: 27,
  hobbies: ["Headlth", "Game"],
  role: Role.ADMIN,
};
```

아래와 같이 직접 특정 숫자로 지정할 수 있다.

```ts
// ADMIN을 5로 지정한 경우 뒤에 라벨들은 +1 씩 증가한다.
enum Role {
  ADMIN = 5,
  READ_ONLY,
  AUTHOR,
} // ADMIN = 5, READ_ONLY = 6, AUTHOR = 7

// 문자도 지정할 수 있다.
enum Role {
  ADMIN = "ADMIN",
  READ_ONLY = 100,
  AUTHOR = "AUTHOR",
} // ADMIN = 5, READ_ONLY = 6, AUTHOR = 7
```

## 모든(Any) 타입

---

가장 유연한 타입으로 모든 종류의 값을 저장할 수 있다.

```ts
// any.ts
let favoriteActivities: any[];
favoriteActivities = ["Health", 1];
```

단 타입스크립트가 주는 모든 장점을 any가 **상쇄**시키기 때문에 **타입스크립트 컴파일러**가 작동하지 않는다.
따라서 어떤 값이나 종류의 데이터가 어디에 저장될지 알 수 없는 경우 혹은 런타임 검사를 수행하는 경우에만 사용한다.<br/>
그 외에는 any를 사용하지 않는게 좋다.

## 조합(Union) 타입

---

아래와 같은 예시로 숫자, 문자가 합쳐진 결과를 반환하는 경우 매개변수에 **Union(|) 타입** 을 이용해 숫자, 문자 타입을
받을 수 있도록 허용할 수 있다.<br/>
단, 연산과정에서 타입스크립트는 유니언 타입만 이해할뿐 유니언 타입 내 어떤 타입의 값이 담겨있는지 알지 못한다.
때문에 이를 **if문을 통한 검증**으로 해결할 수 있다.
```ts
// app.ts
function combine(input1: number | string, input2: number | string) {
  let result;
  if(typeof input1 === 'number' && typeof input2 === 'number'){
    result = input1 + input2;
  }else {
    result = input1.toString() + input2.toString();
  }
  return result;
}

const combinedAges = combine(30, 26);
console.log(combinedAges);
>> 56

const combinedNames = combine('Max', 'Anna');
console.log(combinedNames);
>> MaxAnna
```
타입에 따른 다른 로직을 적용해야하므로 여러 유형의 값으로 작동할 수 있다.

## 리터럴 타입
---