
---

title:  "[Docker Mastery] - 12"

description:  "쿠버네티스 아키텍쳐"

language:  "devops"

category:  "Docker"

update:  "2024-03-19"

hide:  false

serisenumber:  12

---

  

## 시작

  

- [Maximilian Schwarzmüller 님의 Docker & Kubernetes : 실전 가이드 강의를 듣고 작성한 글입니다.](https://www.udemy.com/course/docker-kubernetes-2022/?couponCode=KEEPLEARNING)

  

### 쿠버네티스는 인프라를 관리하지 않는다.

쿠버네티스는 클러스터, 마스턴 노드, 워커 노드를 구성하고 리소스를 생산하지만 파드 모니터링, 파드 컨테이너 모니터링, 파드 교체 및 스케일링, 파드 내부 컨테이너 오케스트레이션, 워커 노드 간 컨테이너 이동 등이 주된 일입니다. 인프라 환경은 직접 구성해야합니다.

  

또한 클라우드 프로바이더가 아니며 컨테이너화된 앱을 배포하는 프레임워크일 뿐입니다. 보안, 시스템 관리, 인스턴스 및 운영 체제 관리 등 쿠버네티스의 역할이 아닙니다. 서버 관리 도구도 아니고 클라우드 프로바이더도 아닌 그저 파드 컨테이너 오케스트레이션 관리 도구입니다.

  

AWS와 같은 클라우드 프로바이더는 EKS와 같은 전용 서비스가 있어 자체 쿠버네티스 구성을 불러올 수 있습니다. ECS를 사용하지 않아도 됩니다. 이와 비슷하게 제공되는 도구인 `Kubermatic`으로 이 인프라 부분은 어느정도 보조할 수 있습니다.

  

즉 `파드와 컨테이너 모니터링 스케일링, 프록시 관리`가 주된 쿠버네티스의 역할입니다.

  

### 인프라 환경을 로컬 환경으로 모방하기

클러스터를 구성하고 마스터 노드를 구성하고 하나 이상의 워커노드를 둔다. 마스터 노드에는 API서버, 스케줄러를 설치하고 워커노드에는 kubelet, 도커가 설치되어 있어야 합니다. 이것이 전반적인 환경입니다.

  

로컬에는 `kubectl`도구가 필요합니다. 배포 변경과 같은 명령을 클러스터에 보내는 역할입니다. 마스터 노드는 워커 노드와 관련해 필요 작업을 수행하고(파드 생성 명령 등) kubectl 도구를 이용해 실제로 클러스터 내부로 명령을 발송하게 됩니다.

  

이제 더미 클러스터를 생성해 이 과정이 수행되는지 확인을 위해 `minikube`도구를 사용해보겠습니다. 이 도구는 주로 테스트 용도로 사용하는 도구입니다. 가상 머신을 사용해 다른 가상 머신을 제어하고 머신에 마스터 노드, 워커 노드 역할을 부여하죠

#### Windows 설치

윈도우로 시작하는 경우에 Pro버전이 아니라면 WSL을 우선 설치합니다. [WSL](https://learn.microsoft.com/en-us/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)

이어서 [Docker Desktop](https://www.docker.com/products/docker-desktop/)도 같이 설치합니다. 설치시 WSL2를 이용하도록 설정합니다.

  

kubectl

  

minikube를 설치하기 이전에 Hypervisor를 설치해야합니다. virtualBox와 같은 드라이버를 이용할 수 있겠죠.

  

이후 드라이버 설치 후 클러스터에 명령할 kubectl를 우선 설치해야합니다.

  

관련 패키지 설치를 위한 툴 [Chocolatey](https://chocolatey.org/install)을 설치합니다.

  

아래 명령을 Powershell -> 관리자 권한으로 실행 후 사용합니다.

  

```bash

Set-ExecutionPolicy  Bypass  -Scope  Process  -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

```

  

이후 kubernetes-cli 를 설치합니다.

  

```bash

choco  install  kubernetes-cli

```

  

버전을 확인합니다.

  

```bash

kubectl  version  --client

```

  

이어서 가상머신 실행을 위한 [virtualBox](https://www.virtualbox.org/wiki/Downloads)를 설치합니다.

  

클러스터로 구성하기 위해 minikube를 설치합니다.

  

```bash

choco  install  minikube

```

  

드라이버를 설정하여 minikube를 실행합니다. [드라이버 목록](https://minikube.sigs.k8s.io/docs/drivers/) 에서 어떤 드라이브가 존재하는지 확인할 수 있습니다.

  

```bash

minikube  start  --driver=virtualbox

```

  

클러스터를 구성하고 마스터 노드, 워커 노드를 구성합니다. 실제로 워커와 마스터 노드가 리소스를 공유하는 하나의 노드만 설정합니다. 개발용이기 때문이죠. 쿠버네티스 소프트웨어, API서버, kubelet도 설치하여 캡슐화된 가상 머신 내부에 모든 것을 설정해줍니다.

  

실행과정에서 다음과 같은 트러블슈팅이 발생할 수 있습니다.

  

```bash

* virtualbox VM (CPUs=2, Memory=6000MB, Disk=20000MB) 를  생성하는  중  ...

* Failed to start virtualbox VM. Running "minikube delete" may fix it: creating host: create: precreate: This computer is running Hyper-V. VirtualBox won't boot a 64bits VM when Hyper-V is activated. Either use Hyper-V as a driver, or disable the Hyper-V hypervisor. (To skip this check, use --virtualbox-no-vtx-check)

  

X Exiting due to PR_VBOX_HYPERV_64_BOOT: Failed to start host: creating host: create: precreate: This computer is running Hyper-V. VirtualBox won't boot a 64bits VM when Hyper-V is activated. Either use Hyper-V as a driver, or disable the Hyper-V hypervisor. (To  skip  this  check,  use  --virtualbox-no-vtx-check)

* 권장: VirtualBox and Hyper-V are having a conflict. Use '--driver=hyperv' or disable Hyper-V using: 'bcdedit /set hypervisorlaunchtype off'

* 관련 이슈들:

-  https://github.com/kubernetes/minikube/issues/4051

-  https://github.com/kubernetes/minikube/issues/4783

```

Hypervisor가 활성화된 경우 virtualBox와 충돌되기 때문입니다. 내장 Hypervisor가 있는 경우 드라이버를 `--driver=hyperv`로 사용해도 되지만, 이 기능이 없는 경우에는 VirtaulBox를 사용할 수 있습니다.

이전 설정은 제거하고 hyperv로 실행합니다. 이 과정에서 명령 프롬프트 환경은 관리자 권한으로 실행한 상태여야 합니다.

M1 실리콘 칩의 경우는 `docker` 드라이버만 지원합니다.

```bash

minikube  delete

minikube  start  --driver=hyperv

```

실행 확인을 위해 상태 정보를 조회합니다.

```bash

minikube status 

```

아래와 같은 정보가 조회되면 정상적인 상태입니다.

```text
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
```

대시보드를 확인합니다.

```bash

minikube dashboard

```

![minikube-dashboard](/snippets/kube/chap1/minikube-dashboard.png)

### kubernetes 내부 동작 이해하기

쿠버네티스는 몇 가지 객체를 가지고 있습니다. 파드, 디플로이먼트, 서비스, 볼륨 ... 등의 객체 입니다. 특정 명령으로 이 객체들을 생성하고 작업을 수행할 수 있습니다. 

#### Pod

파드는 쿠버네티스의 가장 작은 단위입니다. 여러 컨테이너를 포함하고 실행합니다. 하나 혹은 복수의 컨테이너를 가질 수 있죠. 특정워커노드에서요. Pod는 하나 또는 여러 컨테이너를 실행할 뿐 아니라 볼륨 같은 리소스도 공유합니다. 파드에는 클러스터 IP를 가지고 있습니다. 이 IP를 통해 외부 파드와도 통신할 수 있습니다.

동일 클러스터내 여러 파드가 존재하는 경우 localhost를 통해 통신할 수 있습니다.

Pod는 영구적이지 않습니다. 쿠버네티스에 의해 제거되면 저장되는 데이터는 제거됩니다. 볼륨 처럼 데이터를 유지할 수 있지만 기본적으로 제거되니 이 점을 염두해 두어야합니다. 컨테이너 또한 파드의 컨셉과 동일하죠. 

#### Deployment

Deployment  객체는 주요 객체로, 수동으로 pod를 생성해 특정 워커노드로 이동시키지 않습니다. deployment가 우선 동작하여 생성 및 관리해야하는  pod 수, 컨테이너 수에 대한 지침을 제공합니다. deployment는 하나 이상의 파드를 관리합니다. 내부적으로 컨트롤러 객체를 구성하는데, 이를 포함하는 것이 deployment객체입니다. 컨테이너를 생성하고 컨테이너를 생성할 파드, 이 파드를 워커 노드에 배치합니다. 메모리, cpu등도 할당하겠죠. 쿠버네티스가 이 작업을 수행합니다.

deployment가 실패해도 롤백 혹은 이전에 작동한 상태로 되돌릴 수 있습니다. 새 deployment만 시작하면 됩니다. 또한 스케일링도 가능합니다. 더 많고 적은 파드를 생성할 수 있고, cpu메트릭을 수신해 트래픽이 증가하면 추가 파드를 생성하기도 하겠죠. 이것이 deployment객체의 모든 역할 입니다. 기본적으로 deployment객체를 구성하고 쿠버네티스 클러스터에 전송해 요구 사항을 수행합니다.

##### 명령적 접근 방식으로 구성하기

우선 컨테이너를 실행하기 위해 이미지를 생성합니다.

```bash
docker build -t 이름 빌드컨텍스트
```

클러스터로 명령을 보내기 이전 활성 상태인지 확인합니다.

```bash
type: Control Plane
host: Nonexistent
kubelet: Nonexistent
apiserver: Nonexistent
kubeconfig: Nonexistent
```

클러스터로 명령을 보내는 경우, 예로 마스터 노드, 컨트롤 플레인의 경우 `kubectl` 명령을 사용합니다.

아래 명령 및 docs를 이용해 사용법을 익혀둡시다.

```bash
$ kubectl help
```

이제 deployment를 생성해봅시다.

```bash
$ kubectl create deployment first-app --image=kub-first-ap
deployment.apps/first-app created

$ kubectl get deployments
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
first-app   0/1     1            0           2m12

$ kubectl get pods
NAME                         READY   STATUS         RESTARTS   AGE
first-app-6897769c85-t69pv   0/1     ErrImagePull   0          73s
```

이미지 pull에러로 파드가 생성되지 않은 것을 볼 수 있습니다. 컨테이너가 실행되는 공간은 가상 공간입니다. 로컬에 있는 이미지를 가져올 수 없기 때문에 위와 같은 에러가 발생합니다.

로컬에서는 찾을 수 없어서 dockerHub에서 가져오려하지만 Hub에도 이미지가 없는 경우입니다. 이 경우 Hub에 이미지를 업로드해야합니다.

다시 생성이 필요하므로 기존 deployment는 제거합니다.

```bash
$ kubectl delete deployment first-app
deployment.apps "first-app" deleted
```

이미지의 태그를 변경합니다.

```bash
docker tag kub-first-app 레포명/kub-first-ap

docker push 레포명/kub-first-app
```

다시  deployment를 생성합니다.

```bash
kubectl create deployment first-app --image=레포명/kub-first-app
deployment.apps/first-app created

$ kubectl get deployments
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
first-app   1/1     1            1           21s

$ kubectl get pods
NAME                         READY   STATUS    RESTARTS   AGE
first-app-77c589c8b6-k5pln   1/1     Running   0          58s
```

정상적으로 앱이 실행중인 결과를 볼 수 있습니다.

#### kubectl의 작동 배경 되짚어보기