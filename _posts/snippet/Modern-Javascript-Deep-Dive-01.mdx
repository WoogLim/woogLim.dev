---
title: "모던 자바스크립트 다이브"
description: "모던 자바스크립트 딥다이브 읽어보기"
language: "Javascript"
category: "Javascript Basic"
update: "2023-02-16"
serisenumber: 1
---
### 시작
---
이미 알고있던 부분은 빠르게 넘기면서 `스코프`, `호이스팅`과 같이 개념적인 부분을 짚고 정리하는 글입니다.

#### 1. 변수 선언 그리고 var

우선 변수는 아래와 같은 형태로 선언하고 값을 주입합니다.
```js
var value = 10 + 20;
```
인터프리터로 해당 구문을 읽으면 메모리에 결과값을 저장하고 해당 메모리의 주소를 변수에 저장합니다. 여기서 result 식별자는 `30`값을 저장한 메모리 공간의 주소를 참조하게 됩니다.
아래와 같이 변수가 저장됩니다.  

![변수 메모리](https://user-images.githubusercontent.com/51357635/219850880-337e13c6-c6dd-48b3-a0e1-d26f9a0fda1f.png)  

위에 보셨듯이 변수를 선언하려면 ES6 이전까지는 `var`를 이용해왔습니다. `var`키워드에는 여러 단점이 존재합니다. `var`키워드 여러 단점 중 가장 대표적인 것은 `블록 레벨 스코프`를 지원하지 않고 `함수 레벨 스코프`를 지원하죠. 이로 인해 의도치 않은 전역 변수가 생성되기도 합니다.

`ES6`에서 `let`과 `const`키워드를 도입한 이유도 `var`키워드의 단점을 보완하기 위해서입니다. 각 변수 키워드 및 `스코프`에 대해 알아보기 위해 [let, const와 블록 레벨 스코프](https://poiemaweb.com/es6-block-scope)참조하겠습니다.


##### 1.1 블록 레벨 스코프와 함수 레벨 스코프

`scope`는 우리말로 번역하면 `범위`라는 뜻을 가지고 있죠. 즉 스코프란 `변수에 접근할 수 있는 범위`라고 볼 수 있습니다.  
자바스크립트에선 스코프는 2가지 타입이 존재합니다. `전역 스코프`와 `지역 스코프` 타입이 존재합니다.

대부분 프로그래밍 언어는 `블록 레벨 스코프`를 따르지만 자바스크립트는 `함수 레벨 스코프`를 따릅니다.

> `함수 레벨 스코프(Function-level scope)`  
함수 내 선언된 변수는 함수 내에서만 유효하며 외부에서는 참조할 수 없습니다. 즉, 함수 내부에서 선언한 변수는 지역 변수, 함수 외부에서 선언한 변수는 모두 전역 변수이죠.

> `블록 레벨 스코프(Block-level scope)`  
모든 코드 블록`{}`(함수, if문, for문, while문, try/catch문 등)내에서 선언한 변수는 해당 코드 블럭 내에서만 유효하며 해당 코드 블록`{}` 외부에서는 참조할 수 없습니다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이죠.

```js {1, 6} showLineNumbers
var foo = 123; // 전역 변수

console.log(foo) // 123

{
  var foo = 456; // 전역 변수
}

console.log(foo) // 456
```

블록 레벨 스코프를 따르지 않는 `var`키워드 상, 코드 블록 내 변수 `foo`는 전역 변수입니다. 하지만 1번 라인에서 전역 변수 foo가 선언되어 있습니다. `var`키워드를 사용하여 선언한 변수는 중복 선언이 허용됩니다. 따라서 위 코드는 전혀 문제가 없습니다. 다만 코드 블록 내(6번 라인)`foo`는 전역 변수이므로 전역에서 선언된 지역 변수 `foo`의 값 123을 새로운 값 456으로 재할당하여 덮어씁니다.  
이런 문제에 대해 `ES6`에서는 `블록 레벨 스코프`를 따르는 변수를 선언하기 위해 `let` 키워드를 제공합니다.

```js showLineNumbers
let foo = 123; // 전역 변수

{
  let foo = 456; // 지역 변수
  let bar = 456; // 지역 변수
}

console.log(foo); // 123
console.log(bar); // ReferenceError: bar is not defined
```
let 키워드로 선언된 변수는 블록 레벨 스코프를 따릅니다. 위 코드를 보면 코드 블록 내 선언된 변수 `foo`는 블록 레벨 스코프를 갖는 지역 변수입니다. 전역에서 선언된 변수 `foo`와 다른 별개의 변수이죠. 또한 변수 `bar`도 블록 레벨 스코프를 갖는 지역 변수입니다. 따라서 전역에서는 변수 `bar`를 참조할 수 없습니다.

##### 1.2 변수 중복 선언 금지

`var` 키워드로는 동일한 이름을 갖는 변수를 중복해서 선언할 수 있습니다. 하지만 `let`키워드로는 동일한 이름을 갖는 변수를 중복해 선언할 수 없습니다. 변수를 중복 선언한 경우 문법 에러(`SyntaxError`)가 발생합니다.

```js
var foo = 123;
var foo = 456;  // 중복 선언 허용 새로운 
공간에 값이 할당되고 해당 공간의 주소를 foo에 저장한다.

let bar = 123;
let bar = 456;  // Uncaught SyntaxError: Identifier 'bar' has already been declared
```


##### 1.3 호이스팅

자바스크립트는 `ES6`에서 도입된 `let, const`를 포함해 모든 선언(<b>var, let, const, function, class</b>)을 호이스팅합니다. 여기서 `호이스팅(Hoisting)`이란, `var`선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼(아래에 구문이 존재해도 위에서 쓸 수 있도록 우선적으로 메모리 공간에 저장) 동작하는 특성을 말합니다.

하지만 `var`키워드로 선언된 변수와 달리 `let`키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생합니다. 이는 let 키워드로 선언된 변수는 스코프의 시작에서 변수 선언까지 `일시적 사각지대(Temporal Dead Zone(TDG))`에 빠지기 때문입니다.

```js {1} showLineNumbers
console.log(foo); // undefined
var foo;

console.log(bar); // Error: Uncaught ReferenceError: bar is not defined
let bar;
```

<b>🎯잠깐 짚고 넢어갑시다!</b>  
변수 `foo`에 undefined가 저장되는 이유는 변수 선언에 의해 확보된 메모리 공간은 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화되기 때문입니다. 이것은 자바스크립트의 독특한 특징이죠. `undefined`는 자바스크립트에서 제공하는 원시 타입의 값입니다.  
자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행하게 됩니다.
- 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보해 암묵적으로 undefined를 할당해 초기화한다.
- 할당 단계 : undefined로 초기화된 변수에 실제 값을 할당한다.

`var`키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어집니다. 즉, 스코프에 변수를 등록(`선언 단계`)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화(`초기화 단계`)합니다. 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않죠. 해당 공간에 암묵적으로 저장된 `undefined`를 반환하게 됩니다. 이후 변수 할당문에 도달하면 비로소 값이 할당됩니다. 이러한 현상을 `변수 호이스팅(Variable Hoisting)`이라고 합니다.

```js
// 스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.
// 따라서 변수 선언문 이전에 변수를 참조할 수 있다.
console.log(foo); // undefined

var foo;
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

![var 키워드르 선언된 변수의 생명 주기](https://user-images.githubusercontent.com/51357635/219850896-42c37207-cd93-4da8-8a17-44a363b1dfaa.png)  

```js {1-5} showLineNumbers
// 스코프의 선두에서 선언 단계가 실행된다.
// 아직 변수가 초기화(메모리 공간 확보와 undefined로 초기화)되지 않았다.
// 따라서 변수 선언문 이전에 변수를 참조할 수 없다.
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

`let`키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행됩니다. 즉, 스코프에 변수를 등록(`선언단계`)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어집니다. 초기화 이전 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생합니다. 이는 변수가 아직 초기화되지 않았기 때문입니다. 다시 말하면 변수를 위한 메모리 공간이 아직 확보되어 있지 않기 때문입니다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없죠. 스코프의 시작 지점부터 초기화 지점까지 구간을 `일시적 사각지대(Temporal Dead Zone, TDZ)`라고 부릅니다.

![let 키워드르 선언된 변수의 생명 주기](https://user-images.githubusercontent.com/51357635/219850908-800ffa5d-ed4c-4e13-b1d6-a23a1bc8ae8c.png)  

결국 `ES6`에서는 호이스팅이 발생하지 않는 것과 차이가 없어 보입니다. 하지만 그렇지 않습니다 아래 코드를 봅시다.
```js
let foo = 1; // 전역 변수
{
  console.log(foo); // ReferenceError: foo is not defined
  let foo = 2;  // 지역 변수
}
```
위 코드의 경우, 전역 변수 `foo`의 값이 출력될 것으로 예상하셨을겁니다. 하지만`ES6`의 선언문도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생합니다.

ES6의 `let`으로 선언된 변수는 블록 레벨 스코프를 가지므로 코드 블록 내 선언된 변수 `foo`는 지역 변수입니다. 따라서 지역 변수 foo도 해당 스코프에서 호이스팅되고 코드 블록 선두부터 초기화가 이루어 지는 지점까지 일시적 사각지대(TDZ)에 빠지게 딥니다. 따라서 전역 변수 `foo`값이 출력되지 않고 출력 에러가 발생합니다.

##### 1.4 클로저

블록 레벨 스코프를 지원하는 `let`은 `var`보다 직관적입니다. 아래 코드를 봅시다.

```js
var funcs = [];

// 함수의 배열을 생성하는 for 루프의 i는 전역 변수다.
for(var i = 0 ; i < 3 ; i++){
  funcs.push(function() { console.log(i); });
}

// 배열에서 함수를 꺼내어 호출한다.
for(var j = 0 ; j < 3; j++){
  funcs[j]();
}
```
위 코드의 실행 결과로 0, 1, 2를 예상하셨을 겁니다. 하지만 결과는 3이 세 번 출력됩니다. 이유는 for 루프의 var i가 전역 변수이기 때문입니다. 0, 1, 2를 출력하려면 아래와 같은 코드가 필요합니다.

```js
var funs = [];

// 함수의 배열을 생성하는 for 루프의 i는 전역 변수다.
for (var i = 0; i < 3; i++) {
  (function (index) { // index 라는 인수를 사용하는 함수 정의
    funcs.push(function () { console.log(index); });
  }(i)); // 인수 (i)를 사용하여 함수를 즉시 호출
         // i로 외부 함수를 즉시 호출하면 루프가 반복될 때마다 새 클로저가 생성되어 내부 함수가 전달된 i값에 엑세스
}

// 배열에서 함수를 꺼내어 호출한다
for (var j = 0; j < 3; j++) {
  funcs[j]();
}

>> console
0
1
2
```
자바스크립트이 함수 레벨 스코프로 인해 `for`루프의 초기화 식에 사용된 변수가 전역 스코프를 갖게 되어 발생하는 문제를 회피하기 위해 `클로저`를 활용한 방법입니다.

`ES6`의 let 키워드를 for 루프의 초기화 식에 사용하면 클로저를 사용하지 않아도 위 코드와 동일한 동작을 합니다.
```js
var funcs = [];

// 함수의 배열을 생성하는 for 루프의 i는 for 루프의 코드 블록에서만 유효한 지역 변수이면서 자유 변수이다.
for (let i = 0; i < 3; i++) {
  funcs.push(function () { console.log(i); });
}

// 배열에서 함수를 꺼내어 호출한다
for (var j = 0; j < 3; j++) {
  console.dir(funcs[j]);
  funcs[j]();
}
```

`for`루프의 `let i`는 `for loop`에서만 유효한 지역 변수입니다. 또한 `i`는 자유 변수로, for 루프 생명주기가 종료되어도 변수 i를 참조하는 함수가 존해하는 한 계속 유지됩니다.

![console ](https://user-images.githubusercontent.com/51357635/219850913-e3f64461-a681-4c6b-8bf4-8ff47108b4a4.png)  
